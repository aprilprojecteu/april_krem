#!/usr/bin/env python3

# ROS
import rospy

# UP
from unified_planning.plans.plan import PlanKind, Plan
from unified_planning.model.metrics import (
    MinimizeMakespan,
    MinimizeSequentialPlanLength,
)

# April
from april_krem.domain import Domain
from april_krem.plan_dispatcher import PlanDispatcher, KREM_STATE
from april_msgs.msg import (
    GestureBackupButtonStates,
    Gesture,
    PersonGesturesList,
)


class AprilPlanDispatcher:
    def __init__(
        self,
        use_case: str = "",
        temporal_actions: bool = False,
        monitoring: bool = False,
    ):
        self._domain = Domain(use_case=use_case, temporal=temporal_actions)

        self._dispatcher = PlanDispatcher(
            self._domain, monitoring
        )
        self._plan = None
        self._plan_graph = None
        self._goals = []
        self._temporal_actions = temporal_actions

        self._timeout = 60.0

        # Gesture Topic
        self._gestures = rospy.Subscriber(
            "/pem/human/gesture_results", PersonGesturesList, self._gesture_cb
        )

        # Gesture Backup Buttons Topic
        self._gesture_backup_buttons = rospy.Subscriber(
            "/isim/hmi/gesture_backup_buttons",
            GestureBackupButtonStates,
            self._gesture_backup_button_cb,
        )

    def _gesture_backup_button_cb(self, msg: GestureBackupButtonStates):
        # VALIDATE
        if msg.gesture_backup_button_state_0:
            pass
        # CANCEL
        if msg.gesture_backup_button_state_1:
            rospy.logwarn(
                "Gesture Backup Button 1 pressed! Canceling action execution."
            )
            PlanDispatcher.change_state(KREM_STATE.CANCELED)
        # STOP
        elif msg.gesture_backup_button_state_2:
            rospy.logwarn("Gesture Backup Button 2 pressed! Pausing action execution.")
            PlanDispatcher.change_state(KREM_STATE.PAUSED)
        # CONTINUE
        elif msg.gesture_backup_button_state_3:
            rospy.logwarn("Gesture Backup Button 3 pressed! Resuming action execution.")
            PlanDispatcher.change_state(KREM_STATE.ACTIVE)
        # RETRIEVE
        if msg.gesture_backup_button_state_4:
            pass
        # UNUSED
        if msg.gesture_backup_button_state_5:
            pass
        # UNUSED
        if msg.gesture_backup_button_state_6:
            pass
        # HOME?
        if msg.gesture_backup_button_state_7:
            pass

    def _gesture_cb(self, msg: PersonGesturesList):
        # TODO Use complete list
        for gesture in msg.person_gestures_list:
            if gesture.gesture_left.gesture == Gesture.CONTINUE:
                rospy.logwarn("Gesture CONTINUE detected! Execution continues.")
                PlanDispatcher.change_state(KREM_STATE.ACTIVE)
                return
            elif gesture.gesture_right.gesture == Gesture.CONTINUE:
                rospy.logwarn("Gesture CONTINUE detected! Execution continues.")
                PlanDispatcher.change_state(KREM_STATE.ACTIVE)
                return
            elif gesture.gesture_left.gesture == Gesture.STOP:
                rospy.logwarn("Gesture STOP detected! Execution paused.")
                PlanDispatcher.change_state(KREM_STATE.PAUSED)
                return
            elif gesture.gesture_right.gesture == Gesture.STOP:
                rospy.logwarn("Gesture STOP detected! Execution paused.")
                PlanDispatcher.change_state(KREM_STATE.PAUSED)
                return
            elif gesture.gesture_left.gesture == Gesture.CANCEL:
                rospy.logwarn("Gesture CANCEL detected! Execution canceled.")
                PlanDispatcher.change_state(KREM_STATE.CANCELED)
                return
            elif gesture.gesture_right.gesture == Gesture.CANCEL:
                rospy.logwarn("Gesture CANCEL detected! Execution canceled.")
                PlanDispatcher.change_state(KREM_STATE.CANCELED)
                return

    def plan(self, goal=None) -> bool:
        plan = None
        goal_set = self._domain.set_goal(goal)

        if goal_set:
            if self._temporal_actions:
                plan = self._domain.solve(planner_name="aries", metric=MinimizeMakespan())
                if plan is not None:
                    rospy.loginfo("DispatcherROS: Found Plan!")
                    for start, action, duration in plan.timed_actions:
                        rospy.loginfo(
                            "%s: %s [%s]" % (float(start), action, float(duration))
                        )
            else:
                plan = self._domain.solve(
                    planner_name="aries", metric=MinimizeSequentialPlanLength()
                )
                if plan is not None:
                    # Convert to sequential plan for visualization and execution
                    plan = plan.convert_to(PlanKind.SEQUENTIAL_PLAN, self._domain.problem)
                    rospy.loginfo(f"DispatcherROS: Found Plan!\n{plan}")
        else:
            rospy.signal_shutdown("")

        if plan is not None:
            self._plan = plan
            self._plan_graph = self._domain.specific_domain.get_executable_graph(plan)
            return True
        else:
            rospy.logerr("Could not find plan!")
            self._plan = None
            self._plan_graph = None
            return False

    def execute(self) -> bool:
        if self._plan is not None and self._plan_graph is not None:
            rospy.loginfo("DispatcherROS: Started execution of plan!")
            result = self._dispatcher.execute_plan(self._plan, self._plan_graph)
            return result
        else:
            rospy.logerr("No plan available to execute!")
            return False


def main():
    rospy.init_node("plan_executor")
    rospy.loginfo("DispatcherROS: Plan Dispatcher started!")
    use_case = rospy.get_param("~use_case", default="uc6")
    temporal_actions = rospy.get_param("~temporal_actions", default=False)
    goal = rospy.get_param("~goal", default="")
    enable_monitor = rospy.get_param("~enable_monitor", default="False")

    if not goal:
        goal = None

    dispatcher = AprilPlanDispatcher(use_case, temporal_actions, enable_monitor)

    rate = rospy.Rate(10)
    while not rospy.is_shutdown():
        if PlanDispatcher.STATE == KREM_STATE.START:
            pass
        elif PlanDispatcher.STATE == KREM_STATE.ACTIVE:
            plan_found = dispatcher.plan(goal=goal)
            if not plan_found:
                dispatcher._domain.specific_domain._env.reset_env()
                continue
            result = dispatcher.execute()
            rospy.loginfo(
                "DispatcherROS: Dispatcher finished with result " + str(result)
            )
        elif PlanDispatcher.STATE == KREM_STATE.PAUSED:
            pass
        elif PlanDispatcher.STATE == KREM_STATE.CANCELED:
            pass
        elif PlanDispatcher.STATE == KREM_STATE.FINISHED:
            PlanDispatcher.change_state(KREM_STATE.ACTIVE)
            rospy.sleep(10)
        elif PlanDispatcher.STATE == KREM_STATE.ERROR:
            pass
        elif PlanDispatcher.STATE == KREM_STATE.WAITING:
            pass
        rate.sleep()


if __name__ == "__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass
